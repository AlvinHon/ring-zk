use std::ops::{Add, Mul, Neg, Sub};

use num::{Integer, One, Zero};
use poly_ring_xnp1::Polynomial;
use rand::distr::uniform::SampleUniform;

/// A matrix over polynomial rings Z\[x]/(x^n+1).
#[derive(Clone, Debug, PartialEq, Eq)]
pub(crate) struct Mat<T, const N: usize> {
    pub(crate) polynomials: Vec<Vec<Polynomial<T, N>>>,
}

impl<T, const N: usize> Mat<T, N> {
    /// Create a matrix (m x n) from a single polynomial.
    pub fn from_element(m: usize, n: usize, element: Polynomial<T, N>) -> Self
    where
        T: Clone,
    {
        let polynomials = vec![vec![element.clone(); n]; m];
        Mat { polynomials }
    }

    /// Create a diagonal matrix (m x n) with the given polynomial on the diagonal.
    pub fn diag(m: usize, n: usize, element: Polynomial<T, N>) -> Self
    where
        T: Zero + One + Clone,
        for<'a> &'a T: Add<Output = T> + Mul<Output = T> + Sub<Output = T>,
    {
        let mut polynomials = vec![vec![Polynomial::<T, N>::zero(); n]; m];
        for (i, ps_i) in polynomials.iter_mut().enumerate() {
            ps_i[i] = element.clone();
        }
        Mat { polynomials }
    }

    /// Create a matrix (m x 1) from a vector of polynomials.
    pub fn from_vec(polynomials: Vec<Polynomial<T, N>>) -> Self {
        Mat {
            polynomials: polynomials.into_iter().map(|p| vec![p]).collect(),
        }
    }

    /// Convert the matrix (m x 1) to a vector of polynomials.
    ///
    /// # Panics
    /// Panics if the matrix is not (m x 1).
    pub fn one_d_mat_to_vec(self) -> Vec<Polynomial<T, N>> {
        self.polynomials
            .into_iter()
            .map(|p| {
                assert_eq!(p.len(), 1);
                p.into_iter().next().unwrap()
            })
            .collect()
    }

    /// Create a matrix (m x n) with polynomials generated by the given closure.
    pub fn new_with<F>(m: usize, n: usize, mut f: F) -> Self
    where
        T: Integer + SampleUniform + Clone,
        F: FnMut() -> Polynomial<T, N>,
    {
        let polynomials = (0..m)
            .map(|_| (0..n).map(|_| f()).collect::<Vec<_>>())
            .collect::<Vec<_>>();
        Mat { polynomials }
    }

    pub fn dim(&self) -> (usize, usize) {
        let m = self.polynomials.len();
        let n = if self.polynomials.is_empty() {
            0
        } else {
            self.polynomials[0].len()
        };
        (m, n)
    }

    #[allow(clippy::needless_range_loop)]
    pub fn dot(&self, other: &Mat<T, N>) -> Mat<T, N>
    where
        T: Zero + One + Clone,
        for<'a> &'a T: Add<Output = T> + Mul<Output = T> + Sub<Output = T>,
    {
        // mxn * nxp = mxp
        let (m, n) = self.dim();
        let (n2, p) = other.dim();
        assert_eq!(n, n2);

        let mut polynomials = vec![vec![Polynomial::<T, N>::zero(); p]; m];
        for i in 0..m {
            for j in 0..p {
                for k in 0..n {
                    polynomials[i][j] = polynomials[i][j].clone()
                        + self.polynomials[i][k].clone() * other.polynomials[k][j].clone();
                }
            }
        }
        Mat { polynomials }
    }

    #[allow(clippy::needless_range_loop)]
    pub fn add(&self, other: &Mat<T, N>) -> Mat<T, N>
    where
        T: Zero + One + Clone,
        for<'a> &'a T: Add<Output = T> + Mul<Output = T> + Sub<Output = T>,
    {
        let (m, n) = self.dim();
        let (m2, n2) = other.dim();
        assert_eq!(m, m2);
        assert_eq!(n, n2);

        let mut polynomials = vec![vec![Polynomial::<T, N>::zero(); n]; m];
        for i in 0..m {
            for j in 0..n {
                polynomials[i][j] =
                    self.polynomials[i][j].clone() + other.polynomials[i][j].clone();
            }
        }
        Mat { polynomials }
    }

    #[allow(clippy::needless_range_loop)]
    pub fn sub(&self, other: &Mat<T, N>) -> Mat<T, N>
    where
        T: Zero + One + Clone,
        for<'a> &'a T: Add<Output = T> + Mul<Output = T> + Sub<Output = T> + Neg<Output = T>,
    {
        let (m, n) = self.dim();
        let (m2, n2) = other.dim();
        assert_eq!(m, m2);
        assert_eq!(n, n2);

        let mut polynomials = vec![vec![Polynomial::<T, N>::zero(); n]; m];
        for i in 0..m {
            for j in 0..n {
                polynomials[i][j] =
                    self.polynomials[i][j].clone() - other.polynomials[i][j].clone();
            }
        }
        Mat { polynomials }
    }

    /// Multiply the matrix by a scalar.
    pub fn componentwise_mul(&self, element: &Polynomial<T, N>) -> Mat<T, N>
    where
        T: Zero + One + Clone,
        for<'a> &'a T: Add<Output = T> + Mul<Output = T> + Sub<Output = T>,
    {
        let mut polynomials = self.polynomials.clone();
        polynomials
            .iter_mut()
            .for_each(|p| p.iter_mut().for_each(|q| *q = q.clone() * element.clone()));
        Mat { polynomials }
    }

    /// Extend the matrix by adding rows.
    /// Original dimensions: m x n;
    /// New dimensions: (m + m') x n
    pub fn extend_rows(&mut self, other: Mat<T, N>)
    where
        T: Clone,
    {
        let (_, n) = self.dim();
        let (_, n2) = other.dim();
        assert_eq!(n, n2);

        self.polynomials.extend(other.polynomials);
    }

    /// Split the matrix by rows.
    /// Original dimensions: m x n;
    /// New dimensions: (m - r) x n and r x n
    pub fn split_rows(mut self, r: usize) -> (Mat<T, N>, Mat<T, N>) {
        let (m, _) = self.dim();
        let b = self.polynomials.split_off(m - r);
        (
            Mat {
                polynomials: self.polynomials,
            },
            Mat { polynomials: b },
        )
    }

    /// Extend the matrix by adding columns.
    /// Original dimensions: m x n;
    /// New dimensions: m x (n + n')
    pub fn extend_cols(&mut self, other: Mat<T, N>)
    where
        T: Clone,
    {
        let (m, _) = self.dim();
        let (m2, _) = other.dim();
        assert_eq!(m, m2);

        self.polynomials
            .iter_mut()
            .zip(other.polynomials)
            .for_each(|(a, b)| a.extend(b));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const N: usize = 4;

    #[test]
    fn test_dot() {
        let a_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let a = Mat {
            polynomials: vec![vec![a_0_0.clone(), a_0_1.clone()]],
        };

        let b_0_0 = Polynomial::<i32, N>::new(vec![1, 2]);
        let b_1_0 = Polynomial::<i32, N>::new(vec![3, 4]);

        // 2x1 matrix
        let b = Mat {
            polynomials: vec![vec![b_0_0.clone()], vec![b_1_0.clone()]],
        };

        let c = a.dot(&b);

        assert_eq!(
            c.polynomials,
            vec![vec![
                a_0_0.clone() * b_0_0.clone() + a_0_1.clone() * b_1_0.clone()
            ]]
        );
    }

    #[test]
    fn test_add() {
        let a_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let a = Mat {
            polynomials: vec![vec![a_0_0.clone(), a_0_1.clone()]],
        };

        let b_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let b_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let b = Mat {
            polynomials: vec![vec![b_0_0.clone(), b_0_1.clone()]],
        };

        let c = a.add(&b);

        assert_eq!(
            c.polynomials,
            vec![vec![
                a_0_0.clone() + b_0_0.clone(),
                a_0_1.clone() + b_0_1.clone()
            ]]
        );
    }

    #[test]
    fn test_sub() {
        let a_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let a = Mat {
            polynomials: vec![vec![a_0_0.clone(), a_0_1.clone()]],
        };

        let b_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let b_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let b = Mat {
            polynomials: vec![vec![b_0_0.clone(), b_0_1.clone()]],
        };

        let c = a.sub(&b);

        assert_eq!(
            c.polynomials,
            vec![vec![
                a_0_0.clone() - b_0_0.clone(),
                a_0_1.clone() - b_0_1.clone()
            ]]
        );
    }

    #[test]
    fn test_extend_rows() {
        let a_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let mut a = Mat {
            polynomials: vec![vec![a_0_0.clone(), a_0_1.clone()]],
        };

        let b_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let b_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let b = Mat {
            polynomials: vec![vec![b_0_0.clone(), b_0_1.clone()]],
        };

        a.extend_rows(b);

        assert_eq!(
            a.polynomials,
            vec![
                vec![a_0_0.clone(), a_0_1.clone()],
                vec![b_0_0.clone(), b_0_1.clone()]
            ]
        );
    }

    #[test]
    fn test_extend_cols() {
        let a_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let mut a = Mat {
            polynomials: vec![vec![a_0_0.clone(), a_0_1.clone()]],
        };

        let b_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let b_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let b = Mat {
            polynomials: vec![vec![b_0_0.clone(), b_0_1.clone()]],
        };

        a.extend_cols(b);

        assert_eq!(
            a.polynomials,
            vec![vec![
                a_0_0.clone(),
                a_0_1.clone(),
                b_0_0.clone(),
                b_0_1.clone()
            ]]
        );
    }

    #[test]
    fn test_componentwise_mul() {
        let a_0_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_0_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 1x2 matrix
        let a = Mat {
            polynomials: vec![vec![a_0_0.clone(), a_0_1.clone()]],
        };

        let b = Polynomial::<i32, N>::new(vec![1, 2, 3]);

        let a = a.componentwise_mul(&b);

        assert_eq!(
            a.polynomials,
            vec![vec![a_0_0.clone() * b.clone(), a_0_1.clone() * b.clone()]]
        );
    }

    #[test]
    fn test_split_rows() {
        let a_0 = Polynomial::<i32, N>::new(vec![1, 2, 3]);
        let a_1 = Polynomial::<i32, N>::new(vec![4, 5, 6]);

        // 2x1 matrix
        let a = Mat {
            polynomials: vec![vec![a_0.clone()], vec![a_1.clone()]],
        };

        let (b, c) = a.split_rows(1);

        assert_eq!(b.polynomials, vec![vec![a_0.clone()]]);
        assert_eq!(c.polynomials, vec![vec![a_1.clone()]]);
    }
}
